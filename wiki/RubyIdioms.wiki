#summary Ruby conventions and idioms

This document gathers together a bunch Ruby idioms, conventions and patterns (some of them accepted by the community, some of them personal). This is a work in progress, feel free to email me if you have any suggestion (tokland AT gmail.com).  

<wiki:toc max_depth="2" />

= Idioms =

== General formatting ==

Choose a sound formatting style (your first goal should be legibility) and stick with it, knowing when to break the rules (Waldo Emerson: "A foolish consistency is the hobgoblin of little minds"). 

Novice programmers tend to overlook the importance of code looks, but as SICP's authors remarked, programs must be written for people to read, and only *incidentally* for machines to execute. Be *extremely* careful with the code you write.

=== Indentation ===

Use 2 spaces, no tabs, and never ever mix spaces and tabs. Keep your code under 80-char width whenever possible.

=== Whitespaces ===

Leave an space after commas. No spaces after or before a _(_, _[_ or _{_ (when used to build a hash, not in a block):

{{{
array = [1, 2, 3]
hash = {:a => 1, :b => 2}
def fun(arg1, arg2, arg3); end
}}}

But use spaces to let the blocks breathe:

{{{
[1, 2, 3].map { |x| 2 * x }
}}}

Note that some programmers *do* put spaces after "[" {{{[ 1, 2, 3 ]}}} and "{" {{{{ :a => 1 }}}}. You'll see this style throughout Rails code, for example. Maybe it's my Python background, but I'd wish my eyes were gouged away every time I see it. 

=== Naming ===

 * {{{StudlyCaps}}} for classes and modules.
 * {{{ALL_LOWER_UNDERCASE}}} for constants (but also {{{StudlyCaps}}}).
 * {{{lower_undercase}}} for everything elese: methods, attributes, local variables, ...

=== Blank lines ===

My personal rules are:

  * Don't insert empty lines between different indentation levels, only *between* definitions ({{{module}}}, {{{class}}}, {{{def}}}, ...) on the same level. The indentation itself should serve as visual hint. 
  
  * In a given level insert blank lines, sparingly, to separate logic blocks.  

Example:

{{{
module Animals
  class Dog
    attr_accessor :name
    attr_accessor :color
    
    def initialize(name, color)
      self.name = name
      self.color = color
    end
    
    def bark
      "bark, bark"
    end
  end
  
  class Cat
    ....
  end
end
}}}

== Blocks == 

Single line blocks are written with brackets:

{{{
obj.method { |foo| ... }
}}}

Multi-line blocks are written with _do/end_:

{{{
obj.method do |foo|
  ...
  ...
end
}}}

== Multi-line array/hashes ==

There are many ways of writing multi-line array or hashes. I recommend this one:

{{{
array = [
  1,
  2,
  3,
]
}}}

Note the comma even in the last element. This is syntically correct and very handy because you have not to worry if you are writing the last line or no, they are all the same (and you can reorder without more editing). The same for hashes:

{{{
hash = {
  :a => 1,
  :b => { 
    :b1 => "11",
    :b2 => "12",
  },
  :c => 3,
}
}}}


== Use of parenthesis ==

Parenthesis are (usually) optional in Ruby:

{{{
def fun arg1 arg2
  arg1 + arg2
end

fun 1 2 #=> 3
}}}

But my personal advice is: put them. On the other hand, it's common (and looks really good) to ommit them when writing DSL-style code. The best known example are Rails class methods: 

{{{
class Post < ActiveRecord::Base
  belongs_to :blog
end
}}}

== Method name qualifiers ==

If your method returns a boolean, end it with _?_:

{{{
dog.hungry?
}}}
  
If your method does does something "dangerous" (an in-place operation, or it may raise an exception on errors, or it's destructive, etc), end it with _!_:

{{{
database.destroy!
}}} 

== Testing for truth values ==

No, no, no:

{{{
  if !some_object.nil?
    ..
  end
}}}

Yes:

{{{
  if some_object
    ...
  end
}}}

Ruby's objects are always _true_ (in boolean terms) except for {{{nil}}} and {{{false}}}, so the only valid reason to write the verbose {{{object.nil?}}} is telling {{{nil}}} from {{{false}}} (something hardly needed).

== Method arguments ==

No:

{{{
def method(arg1, arg2, arg3=nil, arg4=nil, arg5=nil)
  ...
end
}}}

Yes:

{{{
def method(arg1, arg2, options = {})
  arg3 = options[:arg3] || default_value_for_arg3 
  ...
end
}}}
  
Why:

  * It separates clearly required from optional arguments.
  * You don't have to write intermediate arguments to reach the argument your want. 
  * You'll get a shorted (and cleaner) method signature. Long signatures are a nightmare both to read and call. 

Downside:
 
  * Available options are not explicit, so make sure you document them.
  * You must be careful with default values on boolean options.
  
== Calling functions with key arguments ==

It's not necessary to use explicit {} to indicate it's a hash:

{{{
dog.bark(:volumen => 10, :duration => 5)
}}}

However, if there are lots of options and must be multilined I recommend this:

{{{
dog.bark({
  :volumen => 10, 
  :duration => 5,
  :direction => :ne,
})
}}}

== Unpack enumerables in block arguments ==

No:

{{{
[[1, 2], [3, 4]].each do |array|
  array[0] - array[1]
end
}}}

Yes:

{{{
[[1, 2], [3, 4]].each do |v1, v2|
  v1 - v2
end
}}}
  
Note that you can expand as nested levels as you need to:

{{{
[["hello", [2, 3.3]], ["bye", [4, 1.1]]].each do |string, (integer, float)|
  ...
end
}}}

= Functional Ruby ==

Ruby is not a functional language. In fact, being a classic OOP language it promotes changes in the state of objects. But, at the same time, Ruby comes with great functional capabilities.

This section was getting pretty long, so I moved to its own page: [RubyFunctionalProgramming]

= Build your own toolbox =

== Extend with generic functions ==

So you have a dog named Scooby and want to know if it's in your list of selected dogs. You would probably write:

{{{
["rantanplan", "milu"].include?("scooby") #=> false
}}}

Notice how the code reversed our phrasing. Why don't we create a construction that reflects how we think about the problem? 

{{{
class Object
  def in?(enumerable)
    enumerable.include?(self)
  end
end
}}}

{{{
"scooby".in?(["rantanplan", "milu"]) #=> false
}}}
  
== Use blocks as wrappers ==

Never wrote something similar to this?

{{{
tries = 0
loop do 
  begin
    process
  rescue Exception1, Exception2 => error
    tries += 1
    retry unless tries > 5
    nil
  end
end
}}}
  
There is nothing really wrong with this, but look at the relevant code: it's literally buried in a jumble of infrastructure! Let's abstract the high-level construction so we achieve two goals: 1) we simplify the code, and 2) leave a method to be reused in other projects:

{{{
retry_on_exceptions([Exception1, Exception2], :max_retries => 5) do
  process
end
}}}

In this second version you see right away what it's going on. This example presents a useful pattern: use blocks as high-level abstraction wrappers. The more generic the pattern is, the more reason you should abstract it. This is nothing new, wrappers with callbacks are used everywhere, the difference with Ruby is that blocks make it a easy and beautiful solution to a myriad of scenarios. 

== Some abstractions ==

=== Managing nil's. The Maybe pattern ===

You have find a lost dog and you want to know where he lives. You'll write:

{{{
dog_address = dog.owner.address
}}}

But hey, there are street dogs with no owners. Then you should be careful and do this instead:

{{{
dog_address = dog.owner ? dog.owner.address : nil
}}}  

Not nice, but we can live with it. But what happens if the chain continues? let's say we want to know which city the dog comes from:

{{{
dog_address = dog.owner ? dog.owner.address : nil
dog_address_city = dog_address ? dog_address.city : nil
}}}

We shouldn't be ok with this, each level adds more verbose and repetitive code. There are (at least) three approaches to solve this:

 * Use a wrapper: Activesupport's Object#try.

{{{
require 'active_support/core_ext/object/try'
dog_owner_street = dog.owner.try(:address).try(:street)
}}}

 * Use a proxied object: Ick's Object#maybe.

Rails' {{{try}}} is not bad, but some programmers don't like seeing that their usual {{{object.method}}} turned into {{{object.wrapper(:method)}}}. [http://ick.rubyforge.org/ Ick]'s maybe (or [http://andand.rubyforge.org/ andand], it's the same idea) takes the proxy approach, you simple insert a {{{maybe}}}s the object if it _may be_ nil:

{{{
dog_owner_street = dog.owner.maybe.address.maybe.street
}}}

 * Use a block. Ick's Object#maybe also supports this pattern:

{{{
dog_owner_street = dog.owner.maybe { |owner| owner.address.street }
}}}
  
I'd recommend the second one, the {{{maybe}}} proxy approach without blocks:  compact yet explicit.
  
== Use an script both as library or executable ==

{{{
if __FILE__ == $0
  # this script was not imported but executed, do something interesting here
end
}}}

=== Enumerable#map_select ===

Mathematics notations are known to be exact but terse. Haskell uses an expression called list-comprehension to build easily lists. For example, the square of the odd numbers between 1 and 10:

{{{
[x^2 | x <- [1..10], odd x]
}}}

Python borrowed it:

{{{
[x**2 for x in range(1, 10+1) if x % 2 == 1]
}}}

But, alas, Ruby has no such construction. But we can build our poor man's version of a list-comprehension, as long as we accept the value (usually nil) which is not to be accepted in the output. That's how it looks:

{{{
(1..10).map_select { |x| x**2 if x.odd? }
}}}

Granted, it does not look terrific, but you see the intent. Also, note that list-comprehensions are much more powerful, as they allow nested iterations. Here is a possible implementation:

{{{
module Enumerable
  def map_select(value_for_skip = nil)
    self.inject([]) do |acc, item|
      value = yield(item)
      value == value_for_skip ? acc : acc << value
    end
  end
end
}}}

=== Enumerable#map_detect ===

Simple exercise: fid the first element in a list with a square greater than 10 and return this same value. How to do it:

1) Simple, detect + operation:

{{{
n = [1,2,3,4].detect { |x| x**2 > 10 }
result = n ? n**2 : nil # 16
}}}

Booh, we need to repeat the operation for the matching value and we also need to control that it's not nil. Ugly.

2) It seems we want a map, but also a detect, don't we?:

{{{
result = [1,2,3,4].map do |x| 
  square = x**2
  square if square > 10
end.compact.first # 16
}}} 

Conceptually ok in a lazy language, but Ruby maps the whole input array, so terrible performance.

3) New abstracion Enumerable#map_detect:

{{{
result = [1,2,3,4].map_detect do |x| 
  square = x**2
  square if square > 10 
end # 16
}}}

So our map_detect is in fact a lazy version of the second example (map+compact+first). A possible implementation:

{{{
module Enumerable
  def map_detect(value_for_no_matching = nil)
    self.each do |member|
      if result = yield(member)
        return result
      end
    end
    value_for_no_matching
  end
end
}}}

=== Object#or_else ===

First an intro: Operators in other languages are methods in Ruby. When you write 2 + 3 this is sintantic sugar for 2.+(3). This is cool, you can override all these methods and write nicer code. But && and || are special in Ruby, you can override them, they are operators that must be managed by the interpreter because they deal with short-circuited evalution ({{{false || nil || 1 || "hello"}}} returns 1 without "hello" being evaluated).

Ok, now consider this case where an expression in a short-circuit cannot be written in a single expression, you need more than one:

{{{
result = expr1 || {expr2a; expr2b; ...; expr2final} # not runnable
}}}

The previous code is not valid, you cannot build blocks of code with {...}. We've seen that {{{||}}} is not overridable so we cannot just make it accept a block, we must write or own "or". Let's call it or_else:

results = expr1.or_else {expr2a; expr2b; ...; expr2final}

And that's it, we've got still a lazy behaviour, as block won't be called unless it's really needed. The implementation is as simple as it gets:

{{{
class Object
  def or_else(&block)
    self || yield  
  end
end
}}}

Of course, when if you find {{{Object#or_else}}} useful, you may probably want to use {{{Object#and_also}}}.

== Object#as ==

Look at this code:

area = info[0] * info[1]

At first glance it's not clear what he is doing, isn't this more clear:

width, height = info
area = width * height

It's really good to name things before using. Nothing wrong here, but we needed an extra line to unpack the array. How about that:

area = info.as { |width, height| width * height }

It's a matter of taste, but I think this is pretty clear. Note that you can use this construction to "name" things in a chain:

{{{
document.css("a")[3].href
}}}

But which is the third link in this document?

{{{
document.css("a")[3].as { |link_to_main_page| link_to_main_page.href }
}}} 

Oh, ok, the third link is the link to the main page.

Also, see how to use it to build an expression that reuses multiple times the previous one:

{{{
y = x**2
result = [y, y+1]
}}}

(x**2).as { |y| [y, y+1] }

The implementation of Object#as is straighforward:

{{{
class Object
  def as(&block)
    yield self
  end
}}}

= Conclusion =  

 * Write beautiful code. This is valid for any language, but while some of them just keep getting in your way no matter how hard you try, that's not the case with Ruby.

 * Don't worry about performance too soon: Maintenance of code is very important. Write simple code that works (this does not mean bad code). Profile it to see where the bootle-necks are, and only there, refactor. You know, "premature optimization is the root of all evil".
 
 * Ruby is not a functional language, and that's fine, but don't use it imperatively when there is no reason for it. Blocks provide a powerful mechanism for functional programming. 
 
 * Ruby core developers can't forecast all your needs, but don't resign yourself to the existing toolbox. *Programming is about building abstractions*, your personal toolbox should be growing with each project you write. Reuse and progressively improve them.
 
In a nutshell: Tweak the language to fit your needs so you can write maintainable, beautiful, compact, semantically meaningful code (incidentally, it would be great if it also works as expected!).