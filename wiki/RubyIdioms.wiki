#summary Ruby conventions and idioms

This document shows some Ruby idioms, conventions and patterns (some of them accepted by the community, some of them personal). This is a work in progress, feel free to email me if you have any suggestion (tokland AT gmail.com).  

<wiki:toc max_depth="2" />

= Community-accepted idioms =

== Formatting ==

This applies when programming in any language: choose a sound formatting style (main goal: legibility) and stick with it, knowing when to break the rules (Waldo Emerson: "A foolish consistency is the hobgoblin of little minds"). 

Novice programmers tend to overlook the importance of code looks, but as SICP's authors remarked, programs must be written for people to read, and only *incidentally* for machines to execute. Be *extremely* careful with the code you write.

=== Indentation ===

Use 2 spaces, no tabs, and never ever mix spaces and tabs. Keep your code under 80-char width whenever possible.

=== Whitespaces ===

Leave an space after commas. No spaces after or before a _(_, _[_ or _{_ (when used to build a hash, not in a block):

{{{
array = [1, 2, 3]
hash = {:a => 1, :b => 2}
def fun(arg1, arg2, arg3); end
}}}

But use spaces to let the blocks breathe:

{{{
[1, 2, 3].map { |x| 2 * x }
}}}

Note that some Ruby programmers *do* put spaces after "[" {{{[ 1, 2, 3 ]}}} and "{" {{{{ :a => 1 }}}}. You'll see this style throughout Rails code, for example. Maybe it's my Python background, but I'd wish my eyes were gouged away every time I see it. 

=== Naming ===

 * {{{StudlyCaps}}} for classes and modules.
 * {{{ALL_LOWER_UNDERCASE}}} for constants (but also {{{StudlyCaps}}}).
 * {{{lower_undercase}}} for everything elese: methods, attributes, local variables, ...

=== Blank lines ===

My personal rules are:

  * Don't insert empty lines between different indentation levels, only *between* definitions ({{{module}}}, {{{class}}}, {{{def}}}, ...) on the same level. The indentation itself should serve as visual hint. 
  
  * In a given level insert blank lines, sparingly, to separate logic blocks.  

Example:

{{{
module Animals
  class Dog
    attr_accessor :name
    attr_accessor :color
    
    def initialize(name, color)
      self.name = name
      self.color = color
    end
    
    def bark
      "bark, bark"
    end
  end
  
  class Cat
    ....
  end
end
}}}

== Blocks == 

Single line blocks are written with brackets:

{{{
obj.method { |foo| ... }
}}}

Multi-line blocks are written with _do/end_:

{{{
obj.method do |foo|
  ...
  ...
end
}}}

== Multi-line array/hashes

There are many ways of writing multi-line array or hashes. I recommend this one:

{{{
array = [
  1,
  2,
  3,
]
}}}

Note the comma even in the last element. This is syntically correct and very handy because you have not to worry if you are writing the last line or no, they are all the same (and you can reorder with re-editing). The same for arrays, nested or not:

{{{
my_array = {
  :a => 1,
  :b => { 
    :b1 => "11",
    :b2 => "12",
  },
  :c => 3,
}
}}}


== Use of parenthesis ==

Parenthesis are (usually) optional in Ruby:

{{{
def fun arg1 arg2
  arg1 + arg2
end

fun 1 2 #=> 3
}}}

But my personal advice is: put them. On the other hand, it's common (and looks really good) to ommit them when writing DSL-style code. The best known example are Rails class methods: 

{{{
class Post < ActiveRecord::Base
  belongs_to :blog
end
}}}

== Method name qualifiers ==

If your method returns a boolean, end it with _?_:

{{{
dog.hungry?
}}}
  
If your method does does something "dangerous" (an in-place operation, or it may raise an exception on errors, or it's destructive, etc), end it with _!_:

{{{
database.destroy!
}}} 

== Testing for truth values ==

No, no, no:

{{{
  if !some_object.nil?
    ..
  end
}}}

Yes:

{{{
  if some_object
    ...
  end
}}}

Ruby's objects are always _true_ (in boolean terms) except for {{{nil}}} and {{{false}}}, so the only valid reason to write the verbose {{{object.nil?}}} is telling {{{nil}}} from {{{false}}} (something hardly needed).

== Method arguments ==

No:

{{{
def method(arg1, arg2, arg3=nil, arg4=nil, arg5=nil)
  ...
end
}}}

Yes:

{{{
def method(arg1, arg2, options = {})
  arg3 = options[:arg3] || default_value_for_arg3 
  ...
end
}}}
  
Why:

  * It separates clearly required from optional arguments.
  * You don't have to write intermediate arguments to reach the argument your want. 
  * You'll get a shorted (and cleaner) method signature. Long signatures are a nightmare both to read and call. 

Downside:
 
  * Available options are not explicit, so make sure you document them.
  * You must be careful with default values on boolean options.
  
== Calling functions with key arguments ==

It's not necessary to use explicit {} to indicate it's a hash:

{{{
dog.bark(:volumen => 10, :duration => 5)
}}}

However, if there are lots of options and must be multilined I recommend this:

{{{
dog.bark({
  :volumen => 10, 
  :duration => 5,
  :direction => :ne,
})
}}}

== Unpack enumerables in block arguments ==

No:

{{{
[[1, 2], [3, 4]].each do |array|
  array[0] - array[1]
end
}}}

Yes:

{{{
[[1, 2], [3, 4]].each do |v1, v2|
  v1 - v2
end
}}}
  
Note that you can expand as nested levels as you need to:

{{{
[["hello", [2, 3.3]], ["bye", [4, 1.1]]].each do |string, (integer, float)|
  ...
end
}}}

== Functional Ruby ===

Ruby is not a functional language. In fact, being a classic OOP language it promotes changes in the state of objects. But, at the same time, Ruby comes with great functional capabilities, let's see when to use them.

=== each vs map ===

This is the classic example. Under no circumstance use this imperative pattern:
 
{{{
def do_something_with_array(input)
  array = []
  input.each do |item|
    array << process(item)
  end
  array
end
}}}

The functional approach (map/collect) is shorter, and clearly describes the intent:

{{{
def do_something_with_array(input)
  input.map do |item|
    process(item) 
  end
end
}}}

=== each vs inject ===

Another common usage of {{{Enumerable#each}}} is to fold/reduce/accumulate results:
 
No:

{{{
def get_result_from_array(input)
  result = 0
  input.each do |item|
    result + = item
  end
  result
end
}}}

Use {{{inject}}} instead:

{{{
def get_result_from_array(input)
  input.inject(0) do |acc, item|
    acc + item
  end
end
}}}

Note that in this particular case we could simply write:

{{{
def get_result_from_array(input)
  input.inject(0, :+) # input.sum in Rails
end
}}}
  
= My personal idioms =

== Functional Ruby ==

=== How to create hashes from enumerables ===

Vanilla Ruby has no direct translation from Enumerable to Hash (a sad flaw, in my opinion). That's why novices keep writing this terrible pattern (and how can you blame them?):

{{{
def process_array(input)
  hash = {}
  input.each do |item|
    hash[item] = process(item)
  end
  hash
end
}}}

This is hideous. Period. Is there anything better at hand? on the past the {{{Hash}}} constructor required a flatten collection of consecutive _key/value_ (ugh, a flatten array to describe a mapping?). Fortunately, latest versions of Ruby also take _key/value_ pairs, which makes much more sense (as it's the reverse operation of {{{hash.to_a}}}), and now you can write:

{{{
def process_array(input)
  Hash[input.map do |item|
    [item, process(item)]
  end]
end
}}}

Not bad, but it kind of breaks the natural writing directionality. In a classical functional language you know you will be writing from right to left: 

{{{
> filter even (map (*2) [1,2,3])
[2,4,6]
}}}  

And in a OOP language you'd expect to write from left to right. If we used {{{Hash}}} we'd have to go back. The constructor has an additional problem: you first have to map your input to pairs and then call the constructor; it would be better to do it in a single step. 

What we need is a method in Enumerable that creates a hash from their _key/value_ pairs. [https://github.com/rubyworks/facets Facets] call it Enumerable#mash:

{{{
>> ["functional", "programming", "rules"].map { |s| [s, s.length] }.mash
=> {"rules"=>5, "programming"=>11, "functional"=>10}
}}}

Or in a single step using mash with the block:

{{{
>> [["functional", "programming", "rules"].mash { |s| [s, s.length] }]
=> {"rules"=>5, "programming"=>11, "functional"=>10}
}}}

=== Using each methods in a functional way ===

Ruby's {{{Enumerable}}} has quite a number of handy {{{each_xyz}}} methods, but as we already saw, {{{each}}} loops are imperative. Fortunately, modern versions of Ruby return an Enumerator when these methods are called without a block, so we can now use them in a functional style. 

Example 1: use {{{Enumerable#each_cons}}} to return the pairwise combinations of {{{1..4}}}:

{{{
>> [1, 2, 3, 4].each_cons(2).to_a
=> [[1, 2], [2, 3], [3, 4]]
}}}

Example 2: use {{{Enumerable#each_with_index}}} to return an enumeration {{{[(index, item)]}}}:

{{{
>> ["a", "b", "c"].each_with_index.map(&:reverse)
=> [[0, "a"], [1, "b"], [3, "c"]]
}}}

=== How to accumulate values ===

No:

{{{
output = []
output << 1
output << 2 if i_have_to_add_two
output << 3
}}}

Yes: 

{{{
output = [1, (2 if i_have_to_add_two), 3].compact
}}}

'What is so bad about appending?' you may think. It's not only that the variable name is repeated over and over (not really DRY, isn't it?), the real problem -inherent to imperative programming- is that it expands the scope of variables to the *whole method* (if it's a instance variable, it's expanded to *the whole class*). If you modify variables in-place, you'll have to look throughout the whole method (at least) to see where the variable was updated and how. Ugh.

So this is a another general advice: don't reuse variable, don't update them inplace. {{{x = x + 1}}}? really? which is this magical {{{x}}}?

== Managing nil's. The Maybe pattern ==

You have find a lost dog and you want to know where he lives. You'll write:

{{{
dog_address = dog.owner.address
}}}

But hey, there are street dogs with no owners. Then you should be careful and do this instead:

{{{
dog_address = dog.owner ? dog.owner.address : nil
}}}  

Not nice, but we can live with it. But what happens if the chain continues? let's say we want to know which city the dog comes from:

{{{
dog_address = dog.owner ? dog.owner.address : nil
dog_address_city = dog_address ? dog_address.city : nil
}}}

See? each level adds more verbose and repetitive code. There are (at least) three approaches to solve this:

 * Use a wrapper: Activesupport's Object#try.

{{{
require 'active_support/core_ext/object/try'
dog_owner_street = dog.owner.try(:address).try(:street)
}}}

 * Use a proxied object: Ick's Object#maybe.

Rails' {{{try}}} is not bad, but some programmers don't like seeing that their usual {{{object.method}}} turned into {{{object.wrapper(:method)}}}. [http://ick.rubyforge.org/ Ick]'s maybe (or [http://andand.rubyforge.org/ andand], it's the same idea) takes the proxy approach, you simple insert a {{{maybe}}}s the object if it _may be_ nil:

{{{
dog_owner_street = dog.owner.maybe.address.maybe.street
}}}

 * Use a block. Ick's Object#maybe also supports this pattern:

{{{
dog_owner_street = dog.owner.maybe { |owner| owner.address.street }
}}}
  
I'd recommend the second one, the {{{maybe}}} proxy approach without blocks:  compact yet explicit.
  
== Use an script both as library or executable ==

{{{
if __FILE__ == $0
  # this script was not imported but executed, do something interesting here
end
}}}

== Create your own (growing) generic toolbox ==

=== Example 1: Extend the existing classes and modules ===

So you have a dog named Scooby and want to know if it's in your list of selected dogs. You would probably write:

{{{
["rantanplan", "milu"].include?("scooby") #=> false
}}}

Notice how the code reversed our phrasing. Why don't we create a construction that reflects how we think about the problem? 

{{{
class Object
  def in?(enumerable)
    enumerable.include?(self)
  end
end
}}}

{{{
"scooby".in?(["rantanplan", "milu"]) #=> false
}}}
  
=== Example2: Use blocks as wrappers ===

Never wrote something similar to this?

{{{
tries = 0
loop do 
  begin
    process
  rescue Exception1, Exception2 => error
    tries += 1
    retry unless tries > 5
    nil
  end
end
}}}
  
There is nothing fundamentally wrong, but look at the relevant code: it's literally buried in a jumble of infrastructure!  Let's abstract the construction so 1) we simplify the code, 2) leave a method to be reused in other projects:

{{{
retry_on_exceptions([Exception1, Exception2], :max_retries => 5) do
  process
end
}}}

In this second version you see in a glance what it's going on. This example presents a useful pattern: use blocks as high-level abstraction wrappers.

= All-in-one example =

To sum up some of the patterns we've seen:

{{{
#!/usr/bin/env ruby
require 'rubygems'
require 'trollop'

# Simple implementation of common UNIX tools
module UnixTools
  # Grep lines in input that match regular expression.
  #
  # Options:
  #   :invert_match: Return lines that do NOT match.
  def self.grep(regexp, input, options = {})
    input.select do |line|
      line.match(regexp) ^ options[:invert_match]
    end
  end  
end


if __FILE__ == $0
  options = Trollop::options do
    banner "grep.rb REGEXP [FILE]"
    opt :invert_match, "Invert match", :short => "v"
  end
  unless ARGV.length >= 1
    Trollop::die "Need regular expression as first argument"
    exit 1
  end 
  
  regexp = Regexp.new(ARGV[0])
  input = ARGV[1] ? File.open(ARGV[1]) : $stdin
  UnixTools.grep(regexp, input, options).each do |line|
    puts line
  end
end
}}}

To be imported from another Ruby script:

{{{
require 'grep'
UnixTools.grep(...)
}}}

Or to be executed in a console:

{{{
$ ruby grep.rb traversal /etc/services
}}}

= Conclusion =  

 * Write beautiful code. This is valid for any language, but while some of them just keep getting in your way no matter how hard you try, that's not the case with Ruby.
 
 * Ruby is not a functional language, and that's fine, but don't use it imperatively when there is no reason for it. Blocks provide a powerful mechanism for functional programming. "State of the root of all evil", keep it to a minimum. 
 
 * Ruby core developers can't forecast all your needs, don't resign yourself to the existing toolbox. *Programming is about building abstractions*, your personal toolbox should be growing with each project you write. Reuse them amongst projects and progressively improve them.
 
In a nutshell: Exploit the language so you can write beautiful, compact, clear and semantically meaningful code. There are few languages as suited as Ruby to achieve this goal, don't waste the opportunity.