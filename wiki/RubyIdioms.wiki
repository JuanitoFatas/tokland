#summary Ruby conventions and idioms

This document gathers together a bunch Ruby idioms, conventions and patterns (some of them accepted by the community, some of them personal). This is a work in progress, feel free to email me if you have any suggestion (tokland AT gmail.com).  

<wiki:toc max_depth="2" />

= Idioms =

== General formatting ==

Choose a sound formatting style (your first goal should be legibility) and stick with it, knowing when to break the rules (Waldo Emerson: "A foolish consistency is the hobgoblin of little minds"). 

Novice programmers tend to overlook the importance of code looks, but as SICP's authors remarked, programs must be written for people to read, and only *incidentally* for machines to execute. Be *extremely* careful with the code you write.

=== Indentation ===

Use 2 spaces, no tabs, and never ever mix spaces and tabs. Keep your code under 80-char width whenever possible.

=== Whitespaces ===

Leave an space after commas. No spaces after or before a _(_, _[_ or _{_ (when used to build a hash, not in a block):

{{{
array = [1, 2, 3]
hash = {:a => 1, :b => 2}
def fun(arg1, arg2, arg3); end
}}}

But use spaces to let the blocks breathe:

{{{
[1, 2, 3].map { |x| 2 * x }
}}}

Note that some programmers *do* put spaces after "[" {{{[ 1, 2, 3 ]}}} and "{" {{{{ :a => 1 }}}}. You'll see this style throughout Rails code, for example. Maybe it's my Python background, but I'd wish my eyes were gouged away every time I see it. 

=== Naming ===

 * {{{StudlyCaps}}} for classes and modules.
 * {{{ALL_LOWER_UNDERCASE}}} for constants (but also {{{StudlyCaps}}}).
 * {{{lower_undercase}}} for everything elese: methods, attributes, local variables, ...

=== Blank lines ===

My personal rules are:

  * Don't insert empty lines between different indentation levels, only *between* definitions ({{{module}}}, {{{class}}}, {{{def}}}, ...) on the same level. The indentation itself should serve as visual hint. 
  
  * In a given level insert blank lines, sparingly, to separate logic blocks.  

Example:

{{{
module Animals
  class Dog
    attr_accessor :name
    attr_accessor :color
    
    def initialize(name, color)
      self.name = name
      self.color = color
    end
    
    def bark
      "bark, bark"
    end
  end
  
  class Cat
    ....
  end
end
}}}

== Blocks == 

Single line blocks are written with brackets:

{{{
obj.method { |foo| ... }
}}}

Multi-line blocks are written with _do/end_:

{{{
obj.method do |foo|
  ...
  ...
end
}}}

== Multi-line array/hashes ==

There are many ways of writing multi-line array or hashes. I recommend this one:

{{{
array = [
  1,
  2,
  3,
]
}}}

Note the comma even in the last element. This is syntically correct and very handy because you have not to worry if you are writing the last line or no, they are all the same (and you can reorder without more editing). The same for hashes:

{{{
hash = {
  :a => 1,
  :b => { 
    :b1 => "11",
    :b2 => "12",
  },
  :c => 3,
}
}}}


== Use of parenthesis ==

Parenthesis are (usually) optional in Ruby:

{{{
def fun arg1 arg2
  arg1 + arg2
end

fun 1 2 #=> 3
}}}

But my personal advice is: put them. On the other hand, it's common (and looks really good) to ommit them when writing DSL-style code. The best known example are Rails class methods: 

{{{
class Post < ActiveRecord::Base
  belongs_to :blog
end
}}}

== Method name qualifiers ==

If your method returns a boolean, end it with _?_:

{{{
dog.hungry?
}}}
  
If your method does does something "dangerous" (an in-place operation, or it may raise an exception on errors, or it's destructive, etc), end it with _!_:

{{{
database.destroy!
}}} 

== Testing for truth values ==

No, no, no:

{{{
  if !some_object.nil?
    ..
  end
}}}

Yes:

{{{
  if some_object
    ...
  end
}}}

Ruby's objects are always _true_ (in boolean terms) except for {{{nil}}} and {{{false}}}, so the only valid reason to write the verbose {{{object.nil?}}} is telling {{{nil}}} from {{{false}}} (something hardly needed).

== Method arguments ==

No:

{{{
def method(arg1, arg2, arg3=nil, arg4=nil, arg5=nil)
  ...
end
}}}

Yes:

{{{
def method(arg1, arg2, options = {})
  arg3 = options[:arg3] || default_value_for_arg3 
  ...
end
}}}
  
Why:

  * It separates clearly required from optional arguments.
  * You don't have to write intermediate arguments to reach the argument your want. 
  * You'll get a shorted (and cleaner) method signature. Long signatures are a nightmare both to read and call. 

Downside:
 
  * Available options are not explicit, so make sure you document them.
  * You must be careful with default values on boolean options.
  
== Calling functions with key arguments ==

It's not necessary to use explicit {} to indicate it's a hash:

{{{
dog.bark(:volumen => 10, :duration => 5)
}}}

However, if there are lots of options and must be multilined I recommend this:

{{{
dog.bark({
  :volumen => 10, 
  :duration => 5,
  :direction => :ne,
})
}}}

== Unpack enumerables in block arguments ==

No:

{{{
[[1, 2], [3, 4]].each do |array|
  array[0] - array[1]
end
}}}

Yes:

{{{
[[1, 2], [3, 4]].each do |v1, v2|
  v1 - v2
end
}}}
  
Note that you can expand as nested levels as you need to:

{{{
[["hello", [2, 3.3]], ["bye", [4, 1.1]]].each do |string, (integer, float)|
  ...
end
}}}

== Functional Ruby ===

Ruby is not a functional language. In fact, being a classic OOP language it promotes changes in the state of objects. But, at the same time, Ruby comes with great functional capabilities.

This section has moved to its own page: [RubyFunctionalProgramming]

== Managing nil's. The Maybe pattern ==

You have find a lost dog and you want to know where he lives. You'll write:

{{{
dog_address = dog.owner.address
}}}

But hey, there are street dogs with no owners. Then you should be careful and do this instead:

{{{
dog_address = dog.owner ? dog.owner.address : nil
}}}  

Not nice, but we can live with it. But what happens if the chain continues? let's say we want to know which city the dog comes from:

{{{
dog_address = dog.owner ? dog.owner.address : nil
dog_address_city = dog_address ? dog_address.city : nil
}}}

We shouldn't be ok with this, each level adds more verbose and repetitive code. There are (at least) three approaches to solve this:

 * Use a wrapper: Activesupport's Object#try.

{{{
require 'active_support/core_ext/object/try'
dog_owner_street = dog.owner.try(:address).try(:street)
}}}

 * Use a proxied object: Ick's Object#maybe.

Rails' {{{try}}} is not bad, but some programmers don't like seeing that their usual {{{object.method}}} turned into {{{object.wrapper(:method)}}}. [http://ick.rubyforge.org/ Ick]'s maybe (or [http://andand.rubyforge.org/ andand], it's the same idea) takes the proxy approach, you simple insert a {{{maybe}}}s the object if it _may be_ nil:

{{{
dog_owner_street = dog.owner.maybe.address.maybe.street
}}}

 * Use a block. Ick's Object#maybe also supports this pattern:

{{{
dog_owner_street = dog.owner.maybe { |owner| owner.address.street }
}}}
  
I'd recommend the second one, the {{{maybe}}} proxy approach without blocks:  compact yet explicit.
  
== Use an script both as library or executable ==

{{{
if __FILE__ == $0
  # this script was not imported but executed, do something interesting here
end
}}}

== Build your own toolbox ==

=== Example 1: Extend the existing classes/modules with generic functions  ===

So you have a dog named Scooby and want to know if it's in your list of selected dogs. You would probably write:

{{{
["rantanplan", "milu"].include?("scooby") #=> false
}}}

Notice how the code reversed our phrasing. Why don't we create a construction that reflects how we think about the problem? 

{{{
class Object
  def in?(enumerable)
    enumerable.include?(self)
  end
end
}}}

{{{
"scooby".in?(["rantanplan", "milu"]) #=> false
}}}
  
=== Example2: Use blocks as wrappers ===

Never wrote something similar to this?

{{{
tries = 0
loop do 
  begin
    process
  rescue Exception1, Exception2 => error
    tries += 1
    retry unless tries > 5
    nil
  end
end
}}}
  
There is nothing fundamentally wrong with this, but look at the relevant code: it's literally buried in a jumble of infrastructure! Let's abstract the high-level construction so 1) we simplify the code, 2) leave a method to be reused in other projects:

{{{
retry_on_exceptions([Exception1, Exception2], :max_retries => 5) do
  process
end
}}}

In this second version you see right away what it's going on. This example presents a useful pattern: use blocks as high-level abstraction wrappers. The more generic the pattern is, the more reason you should abstract it.

= Some abstractions =

== Enumerable#map_detect ==

Simple exercise: fid the first element in a list with a square greater than 10 and return this same value. How to do it:

1) Simple, detect + operation:

{{{
n = [1,2,3,4].detect { |x| x**2 > 10 }
result = n ? n**2 : nil # 16
}}}

Booh, we need to repeat the operation for the matching value and we also need to control that it's not nil. Ugly.

2) It seems we want a map, but also a detect, don't we?:

{{{
result = [1,2,3,4].map do |x| 
  square = x**2
  square if square > 10
end.compact.first # 16
}}} 

Conceptually ok in a lazy language, but Ruby maps the whole input array, so terrible performance.

3) New abstracion Enumerable#map_detect:

{{{
result = [1,2,3,4].map_detect do |x| 
  square = x**2
  square if square > 10 
end # 16
}}}

So our map_detect is in fact a lazy version of the second example (map+compact+first).

= Conclusion =  

 * Write beautiful code. This is valid for any language, but while some of them just keep getting in your way no matter how hard you try, that's not the case with Ruby.
 
 * Ruby is not a functional language, and that's fine, but don't use it imperatively when there is no reason for it. Blocks provide a powerful mechanism for functional programming. "State of the root of all evil", keep it to a minimum. 
 
 * Ruby core developers can't forecast all your needs, but don't resign yourself to the existing toolbox. *Programming is about building abstractions*, your personal toolbox should be growing with each project you write. Reuse and progressively improve them.
 
In a nutshell: Exploit the language so you can write beautiful, compact, clear and semantically meaningful code. There are few languages as suited as Ruby to achieve this goal, don't waste the opportunity.