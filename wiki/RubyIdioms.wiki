#summary Ruby conventions and idioms

Small recopilation of Ruby conventions, idioms and patterns (some common, accepted by the whole community, some personal). Work on progress, email if you have any suggestion.  

= Community-accepted idioms =

== Formatting ==

This is not particular of Ruby: choose a formatting style in any language you program and stick with it (knowing when to break the rules, Waldo Emerson: "A foolish consistency is the hobgoblin of little minds"). Novice programmers tend to overlook the importance of code looks, but as SICP's authors remarked: "Programs must be written for people to read, and only incidentally for machines to execute". Be *extremely* careful with the code you write.

=== Indentation ===

Use 2 spaces, no tabs, and never ever mix spaces and tabs. Keep your code under 80 chars width whenever possible.

=== Whitespaces ===

Leave an space after commas. No spaces after or before (, [ or { (when used to build a hash):

{{{
array = [1, 2, 3]
hash = {:a => 1, :b => 2}
def fun(arg1, arg2, arg3); end
}}}

But use spaces to let the blocks "breath":

{{{
[1, 2, 3].map { |x| 2 * x }
}}}

Note: some Ruby programmers *do* put spaces after "[" {{{[ 1, 2, 3 ]}}} and "{" {{{{ :a => 1 }}}}. You'll see this style in Rails code, for example. Maybe it's my Python background, but I just wish my eyes were gouged away every time I see it. So I cannot but break this convention (if any such exists).  

=== Naming ===

 * {{{StudlyCaps}}} for classes and modules.
 * {{{ALL_UPPERCASE}} for constants.
 * {{{lower_undercase}}} for methods, attributes and local variables.

=== Blank lines ===

My personal rules are:

  * Don't add empty lines between different indentation levels, only between definitions ({{{module}}}, {{{class}}}, {{{def}}}, ...) in the same level. The indentation itself serves as visual hint.
  
  * In a given level insert blank lines, sparingly, to distinguish logic blocks.  

Example:

{{{
module MyModule
  class Dog
    attr_accessor :name
    attr_accessor :color
    
    def initialize(name, color)
      self.name = name
      self.color = color
    end
    
    def bark
      "bark, bark"
    end
  end
  
  class Cat
    ....
  end
end
}}}

== Blocks == 

Single line blocks are written with brackets:

{{{
obj.method { |foo| ... }
}}}

Multi-line blocks are written with _do/end_:

{{{
obj.method do |foo|
  ...
  ...
end
}}}

== Use of parenthesis ==

Parenthesis are (usually) optional in Ruby:

{{{
def fun arg1 arg2
  arg1 + arg2
end

fun 1 2 #=> 3
}}}

But my personal advice is: write them. On the other hand, it's common to ommit when writing DSL-style calls. The best known example is Rails: 

{{{
class Post < ActiveRecord::Base
  belongs_to :blog
end
}}}

== Method name qualifiers ==

If your method returns a boolean, end it with _?_:

{{{
dog.hungry?
}}}
  
If your method does does something "dangerous" (in-place operation, may raise an exception on errors, destructive, etc), end it with _!_:

{{{
database.destroy!
}}} 

== Testing for truth values ==

No:

{{{
  if some_object.nil?
    ..
  end
}}}

Yes:

{{{
  if some_object
    ...
  end
}}}

Ruby's objects are always _true_ (in boolean terms) except for {{{nil}}} and {{{false}}}, so the only valid reason to write the verbose {{{object.nil?}}} is telling {{{nil}}} from {{{false}}} (something hardly needed).

== Method arguments ==

No:

{{{
def method(arg1, arg2, arg3=nil, arg4=nil, arg5=nil)
  ...
end
}}}

Yes:

{{{
def method(arg1, arg2, options = {})
  arg3 = options[:arg3] || default_value_for_arg3 
  ...
end
}}}
  
Why:

  * It separates clearly required arguments from optional.
  * You don't have to write intermediate arguments to specify a argument on the right. 
  * Shorted (and cleaner) signature. Long signatures are a nightmare to read and call. 

Downside:
 
  * Available options are not explicit, so make sure you document them.
  * You must be careful with default values on boolean options.
  
== Expand enumerables in block arguments ==

No:

{{{
[[1, 2], [3, 4]].each do |array|
  array[0] - array[1]
end
}}}

Yes:

{{{
[[1, 2], [3, 4]].each do |v1, v2|
  v1 - v2
end
}}}
  
Note that you can expand as nested levels as you need to:

{{{
[["hello", [2, 3.3]], ["bye", [4, 1.1]]].each do |string, (integer, float)|
  ...
end
}}}

== Take head/tail from enumerables ==

No:

{{{
array = [1, 2, 3, 4]
head = array.first
tail = array[1..-1]
}}}

Yes:

{{{
head, *tail = array
}}}
  
= Functional Ruby ==

Ruby is not a functional language. In fact, being an OOP language it tacitly promotes state changes in objects. But, at the same time, Ruby comes with great functional capabilities, know them and use them.

=== each vs map ===

This imperative pattern is ugly, verbose, and convoluted:
 
{{{
def do_something_with_array(input)
  array = []
  input.each do |item|
    array << process(item)
  end
  array
end
}}}

The functional approach (map/collect) is shorter and clearer:

{{{
def do_something_with_array(input)
  input.map do |item|
    process(item) 
  end
end
}}}

=== each vs inject ===

Another common usage of each is to accumulate results:
 
{{{
def get_result_from_array(input)
  result = 0
  input.each do |item|
    result + = item
  end
  result
end
}}}

Use inject:

{{{
def get_result_from_array(input)
  input.map(&:process).inject(0) do |acc, item|
    acc + item
  end
end
}}}

Note that in this particular case we could simply write:

{{{
def get_result_from_array(input)
  input.inject(0, :+)
end
}}}
  
= My personal idioms =

Those are idioms that I've found useful and use in all my projects.   

== Functional Ruby ==

=== How to create hashes from enumerables ===

Vanilla Ruby has no direct translation from Enumerable to Hash (a sad flaw, in my opinion). That's why novices keep writing this terrible pattern (and how can you blame them?):

{{{
def process_array(input)
  hash = {}
  input.each do |item|
    hash[item] = process(item)
  end
  hash
end
}}}

This is hideous. Period. But there is something better at hand: the old {{{Hash}}} constructor used to take a flatten collection of consecutive _key/value_ (not such a great idea). Fortunately, latest versions of Ruby take _key/value_ pairs, which makes much more sense; now you can write:

{{{
def process_array(input)
  Hash[input.map do |item|
    [item, process(item)]
  end]
end
}}}

Not bad, but it kind of breaks the natural writing directionality of object-oriented programming. In a functional language you know you will be writing from right to left: 

{{{
> filter even (map (*2) [1,2,3])
[2,4,6]
}}}  

In a OOP language I expect to write from left to right. If I use {{{Hash}} I have to go back. The constructor has an additional problem: you first have to map your input to pairs and then transform them; it would be nice (and faster) to do it in a single step (if we want). What we need is a method in Enumerable that creates a hash from their _key/value_ pairs. [https://github.com/rubyworks/facets Facets] call it Enumerable#mash, let's call it the natural to_hash:

>> ["functional", "programming", "rules"].map { |s| [s, s.length] }.to_hash
=> {"rules"=>5, "programming"=>11, "functional"=>10}

Or in a single step:

>> [["functional", "programming", "rules"].to_hash { |s| [s, s.length] }]
=> {"rules"=>5, "programming"=>11, "functional"=>10}

=== Using each methods in a functional way ===

Ruby's {{{Enumerable}}} have quite a number of handy {{{each_xyz}}} methods, but as we have seen, {{{each}}} loops mean imperative style (appending to arrays and other stateful patterns). Fortunately Ruby 1.9 (and Ruby 1.8 with backports) now return an Enumerator when these methods are called without a block, so we can now use these collection of methods in a functional way. 

Example 1: use {{{Enumerable#each_cons}}} to return the pairwise combinations of {{{1..4}}}:

{{{
>> [1, 2, 3, 4].each_cons(2).to_a
=> [[1, 2], [2, 3], [3, 4]]
}}}

Example 2: use {{{Enumerable#each_with_index}}} to return a enumeration {{{[(index, item)]}}}:

{{{
>> ["a", "b", "c"].each_with_index.map(&:reverse)
=> [[0, "a"], [1, "b"], [3, "c"]]
}}}

=== How to accumulate values ===

No:

{{{
output = []
output << 1
output << 2 if i_have_to_add_two
output << 3
}}}

Yes: 

{{{
output = [1, (2 if i_have_to_add_two), 3].compact
}}}

But what is so bad about appending? you may think... It's not only that the variable name is repeated over and over (not really DRY, isn't it), the real problem (inherent to imperative programming) is that it expands the scope of the variable to the *whole method* (if it's a instance variable, it's expanded to *the whole class*). When you see this variable somewhere in this function you need to check the complete scope to see if it was updated, and how. Ugh.

So this is a another general advice: don't reuse variable names nor modify them in-places. {{{x = x + 1}}}? what would our school math teacher say? 

== Managing nil's. The Maybe pattern ==

You have find a lost dog and you want to know its owner's address. You'll write:

{{{
dog_address = dog.owner.address
}}}

But hey, there are street dogs with no owners. Then you should be careful and write this instead:

{{{
dog_address = dog.owner ? dog.owner.address : nil
}}}  

Not nice, but we can live with it. But what happens if the chain continues? let's say we want to know which city the dog comes from:

{{{
dog_address = dog.owner ? dog.owner.address : nil
dog_address_city = dog_address ? dog_address.city : nil
}}}

See? each level adds verbose and repetitive code. There are (at least) three approaches to solve this:

 * Use a wrapper: Rails's Object#try.

{{{
require 'active_support/core_ext/object/try'
dog_owner_street = dog.owner.try(:address).try(:street)
}}}

 * Use a proxied object: Ick's Object#maybe.

Rails's {{{try}}} is not bad, but some programmers don't like seeing that the usual {{{object.method}}} turned into {{{object.wrapper(:method)}}}. [http://ick.rubyforge.org/ Ick]'s maybe (or [http://andand.rubyforge.org/ andand], it's the same idea) takes the proxy approach, you simple intersperse {{{maybe}}}s on method calls:

{{{
dog_owner_street = dog.owner.maybe.address.maybe.street
}}}

 * Use a block. Ick's Object#maybe also supports this pattern:

{{{
dog_owner_street = dog.owner.maybe { |owner| owner.address.street}
}}}
  
I'd recommend the second, the {{{maybe}}} proxy approach: explicit yet compact.
  
== Use an script both as library or executable ==

{{{
if __FILE__ == $0
  # this script was not imported but executed, do something interesting here
end
}}}

== Create your own (growing) generic toolbox ==

=== Example1: Extend the existing classes and modules ===

So you have a dog named Scooby and want to know if it's in your list of selected dogs. You would probably write:

{{{
["rantanplan", "milu"].include?("scooby") #=> false
}}}

Notice how the code reverse the phrasing of our specification. Why don't we create a construction to reflect how we think about the problem? 

{{{
class Object
  def in?(enumerable)
    enumerable.include?(self)
  end
end
}}}

{{{
"scooby".in?(["rantanplan", "milu"]) #=> false
}}}
  
=== Example2: Use blocks as wrappers ===

Probably you have written this from time to time:

{{{
tries = 0
loop do 
  begin
    # relevant code
  rescue Exception1, Exception2 => error
    tries += 1
    retry unless tries > 5
    nil
  end
end
}}}
  
Look at the relevant code; it's literally buried in a jumble of infrastructure!  Abstract you own construction that goes to the point and re-use it in your projects:

{{{
retry_on_exceptions([Exception1, Exception2], :max_retries => 5) do
  # relevant code
end
}}}
  
This example presents a useful pattern: you can use blocks as high-level wrappers of all kinds.

= All-in-one example =

To sum up some of the patterns seen:

{{{
#!/usr/bin/env ruby
require 'rubygems'
require 'trollop'

# Simple implementation of common UNIX tools
module UnixTools
  # Grep lines in input that match regular expression.
  #
  # Options:
  #   :invert_match: Return lines that do NOT match.
  def self.grep(regexp, input, options = {})
    input.select do |line|
      line.match(regexp)
    end
  end  
end


if __FILE__ == $0
  options = Trollop::options do
    banner "grep.rb REGEXP [FILE]"
    opt :invert_match, "Invert match", :short => "v"
  end
  unless ARGV.length >= 1
    Trollop::die "Need regular expression as first argument"
    exit 1
  end 
  
  regexp = Regexp.new(ARGV[0])
  input = ARGV[1] ? File.open(ARGV[1]) : $stdin
  UnixTools.grep(regexp, input, options).each do |line|
    puts line
  end
end
}}}

To be imported from another Ruby script:

{{{
require 'grep'
UnixTools.grep(...)
}}}

Or to be executed in a console:

{{{
$ ruby grep.rb traversal /etc/services
}}}

= Conclusion =  

 * Write beautiful code. This is valid for any language, but some of them just keep getting in your way. That's not the case with Ruby.
 
 * Ruby is not a functional language, and this is fine, but don't use it imperatively when there is no valid reason for it. "State of the root of all evil", keep it to a minimum. 
 
 * Ruby developers can't forecast all your needs, but don't resign yourself to the existing toolbox, build your own. *Programming is about building abstractions*, your personal toolbox should be growing with each project you write.
 
Exploit the language so you can write beautiful, compact, clear and semantically meaningful code. There are few languages as suited as Ruby to achieve this goal, don't waste the opportunity.