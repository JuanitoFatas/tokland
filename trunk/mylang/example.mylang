# Features:
#
# functional (impure)
# statically typed
# type constructors (with ADT)
# type inference?
# type classes (+ instances)
# whitespace-aware syntax
# boolean, float, string, array, hash/records
# pattern-matching
# impure side-effects
# monadic syntatic sugar for CPS
# exceptions or function return with typed ok/error?

# basic types
boolean1 = True
boolean2 = False
string1 = "hello there"
integer = 10
float = 10.3

# list or arrays, depending on implementation
list1 = [1, 2, 3, 4]
list2 = [1..10]
list1!2 # access 3th-element (0-indexing)
list1 ++ list2 # list concatenation

# records
> record1 = {a1: "one", a2: 2} 
{a1: "one", a2: 2} : {a1: String, a2: Int} 
> record1.a2 
2 : Int

# nested records:
> record1 = {a1: "one", a2: {b1: 4}} 
{a1: "one", a2: 2} : {a1: String, a2: Int} 
> record1.a2.b1 
4

# functions (Ocaml style without let, and with parens)
# Allow only one function definition (and use case)
 
square_of_sums(x:Num, y:Num):Num =
  sum = x + y 
  sum^2

# functions (Ocaml style without let, and with parens) 
add_sums(x:Num, y:Num):Num =
  x + y 

# normal call
add(10, 20)

# equivalent to a partial application
add(10)(20)

# optional labeled arguments
add(x=10, y=20)

# sections
(+3)(5)
#=> 8

# type constructors + ADT
# how to unify function arguments/type constructor arguments with records. 
type Boolean = True | False
type Maybe(a) = Nothing | Just(a)
type Tree(a) = Empty | Leaf(a) | Node({node:a, left:Tree(a), right:Tree(a)})
type Tree(a) = Empty | Leaf(a) | Node(node:a, left:Tree(a), right:Tree(a)) # optional {} ?
type Tree(a) = Empty | Leaf(a) | Node(a, left:Tree(a), right:Tree(a)) #?
type Options = Options({arg1: Integer, arg2: Maybe([String])})

some_maybe = Just("hello")
some_tree = Node(2, left=Leaf(5), right=Empty)
options1 = Options(arg1=1, arg2=["hello", "there"])
options2 = Options(arg1=2, arg2=Nothing)

# type aliases
typealias FilePath = String

# type class interface
typeclass Show(a)
  toString(a): String.

# add type to class    
typeinstance Show(Int)
  toString(x:Int) = js.toString(x)

# type deriving default implementations in classes    
type Boolean deriving(Eq, Ord, Enum, Show) = 
  True | False

# restrict class for functions
process(x:a, y:a):a where(a:Eq, a:Ord) =
  d = if x > y then 1 else 0 
  x + y + d

# anonymous functions, some ideas:
f = \x -> 2*x
f = |x| -> 2*x

# multi-line maps. Let's put the function mapping the last argument so we can
# write Ruby-like blocks.
ys = map([1..10], |x| ->
  y = 2
  x * y
)

# what about emulating dot as a OOP syntantic sugar? 
# x.function(arg1, arg2) equivalent to function(x, arg1, arg2)
# Note that Haskell "allows" it: let (.) = flip ($); [1,2,3].map(\x -> 2*x).map(\x -> x+1)

ys = [1..10].map(|x| ->
  y = 2
  x * y
).reject(|x| ->
  x > 4
) 

# list-comprehensions (Python syntax)
[2*x + y for x in [1..10] for y in [1..5] if x+y > 2]

# conditionals
some_string = if true then "yes" else "no"

# multi-line conditionals
greeting = if name == "Anne" [then]
  s = "hello: "
  s + name 
else 
  "bye: #{name}"

result = case value
  1 ->
    s = "o" 
    s + "ne"
  2 -> "two"
  
type Shape = Square(side:Num) | Circle(radius:Num)

# with pattern matching, deconstruct
surface(shape:Shape) =
  case shape
    Square(side) -> side * side
    Circle(radius) -> math.pi * radius**2 

# this makes sense? no deconstruct, only get by type (+ name binding), and record access
surface(shape:Shape) =
  case shape
    square:Square -> square.side * square.size
    circle:Circle -> math.pi * circle.radius**2 
    
# you can return anywhere in a function. Not very functional, but convenient to be used as guards.
add(x:Num, y:Num): Num =
  if x == 0 && y == 0
    return 0
  x + y

# how to deal with side-effects? the simplest is to be unpure and allow them 
readFileAndSize(paths:[String]): Hash(length:Int, contents:String) =
  contents = paths.mash(|path| ->
    contents = readFile(path):String 
    (length(contents), contents)
  )

main =
  readFileAndSize(["/etc/hosts", "/etc/passwd"])

# if no exceptions, to manage errors similator to Either
type OkFail(a) = Ok(a) | Fail(reason:String)

getFileSize(path:String): OkFail(Int) =
  if fileExists(path)
    Ok(fileSize(path))
  else
    Fail("file not found")
  
# module imports (python style)
import system.environment # system.environment.funcname
import system.environment as env # env.funcname 
import from system.environment(funcname, funcname2) # funcname"
